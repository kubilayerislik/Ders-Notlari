### Uygulama 1: Yapay Sinir Ağları ile El Yazısı Algılama

Uygulamaya geçmeden önce ilk olarak yapılması gereken işlem; kullanılacak olan kütüphaneler import işlemi ile çalışmaya dahil edilmelidir. Bu projece Numpy, Pandas ve Matplotlib kütüphaneleri kullanılacaktır.

```python
#Gerekli Kütüphanelerin Çalışmaya Eklenmesi
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
```

Bu uygulamada kullanılacak olan veri seti https://www.kaggle.com/code/ngbolin/mnist-dataset-digit-recognizer/ linkte bulunan ve el yazısı ile yazılmış olan rakamların pixellerinin kodlanmış halidir. Bu sayede değişkenlerin grafiği çizildiğinde elle yazılan rakam tanımlanabilecektir.  İlk olarak pandas kütüphanesi kullanılarak kullanılacak veri seti python'a dahil edilir.
```python
#Veri Setinin Oluşturulması
data = pd.read_csv("train.csv")
data
```

![](https://i.imgur.com/dUg8VC9.png)

```python
#Veri Setinin Analize Uygun Hale Getirilmesi
data = np.array(data)
m, n = data.shape
np.random.shuffle(data)

#Verinin Test Kısmının Ayrılması
data_test = data[0:1000].T
Y_test = data_test[0]
X_test = data_test[1:n]
X_test = X_test / 255.

#Verinin Train Kısmının Ayrılması
data_train = data[1000:m].T
Y_train = data_train[0]
X_train = data_train[1:n]
X_train = X_train / 255.
_,m_train = X_train.shape
```

Verilerin oluşturulma işlemleri yapıldıktan sonra yapılması gereken yapay sinir ağlarında kullanılacak olan fonksiyonların oluşturulması gerekmektedir.  İlk olarak tanımlanacak fonksiyon init_params() fonksiyonu bu fonksiyon ile ağırlıklar ve eşik değerlerin tanımlanması yapılacaktır. Yapılan çalışmada 2 gizli katman kullanılacak olduğundan W1 ve W2 matrisleri olarak ağırlık matrisleri tanımlanacak ayrıca iki adet eşik değer de b1 ve b2 olarak tanımlanacaktır.

 ```python
def init_params():
	W1 = np.random.rand(10,784) - 0.5
	b1 = np.random.rand(10,1) - 0.5
	W2 = np.random.rand(10, 10) - 0.5
	b2 = np.random.rand(10, 1) - 0.5
	return W1, b1, W2, b2
```

Parametreler tanımlandıktan sonra yapılacak bir sonraki işlem ise yapay sinir ağlarında kullanılacak olan aktivasyon fonksiyonlarının tanımlanması gerekmektedir. Bu çalışmada girdilerin tamamı 0 ve 1 lerden oluşmaktatır. Çıktılar ile 0 - 9 arasındaki rakamlardan oluşmaktadır. Bundan dolayı çalışmada gizli katmanların birincisinde ReLU aktivasyon fonksiyonu kullanılırken ikinci gizli katmanda ise softmax aktivasyon yöntemi kullanılacaktır. 

```python
def Relu(Z):
	return np.maximum(Z, 0)

def softmax(Z):z
	A = np.exp(Z) / sum(np.exp(Z))
	return A

def ReLU_deriv(Z):
	return Z > 0
```

Aktivasyon fonksiyonları oluşturulduktan sonra ileri doğru hesaplama kısmının hesaplanacağı  forward_prop() fonksiyonunun tanımlanması gerekmektedir.  İleri doğru hesaplamada kullanılacak değişkenler; W1, b1, W2, b2 ve X değişkenleridir.

```python
def forward_prop(W1, b1, W2, b2, X):
	Z1 = W1.dot(X) + b1
	A1 = ReLU(Z1)
	Z2 = W2.dot(A1) + b2
	A2 = softmax(Z2)
	return Z1, A1, Z2, A2
```

İleri doğru hesaplama fonksiyonu tanımlandıktan sonra hesaplanan çıktı  ile gerçek Y  değerlerinin karşılaştırılabilmesi Y değerlerinin düzenlenmesi için gerekli fonksiyonun tanımlanması gerekmektedir. 

```python
def reel(Y):
	reel_Y = np.zeros((Y.size, Y.max() + 1))
	reel_Y[np.arange(Y.size), Y] = 1
	reel_Y = Reel_Y.T
	return reel_Y
```

İleri Hesaplama işlemlerinin gerekli fonksiyonları tanımlandıktan sonra yapılması gereken ilk işlem geri doğru besleme için gerekli hesaplama fonksiyonunun oluşturulması gerekmektedir.

```python
def backward_prop(Z1, A1, Z2, A2, W1, W2, X, Y):
	reel_Y = reel(Y)
	dZ2 = A2 - reel_Y
    dW2 = 1 / m * dZ2.dot(A1.T)
    db2 = 1 / m * np.sum(dZ2)
    dZ1 = W2.T.dot(dZ2) * ReLU_deriv(Z1)
    dW1 = 1 / m * dZ1.dot(X.T)
    db1 = 1 / m * np.sum(dZ1)
    return dW1, db1, dW2, db2
```

Geri besleme hesaplamalarının yapılacağı fonksiyondan sonra parametrelerin güncellenmesi amacıyla kullanılacak olan fonksiyonun tanımlanması gerekmektedir.

```python
def update_params(W1, b1, W2, b2, dW1, db1, dW2, db2, alpha):
    W1 = W1 - alpha * dW1
    b1 = b1 - alpha * db1    
    W2 = W2 - alpha * dW2  
    b2 = b2 - alpha * db2    
    return W1, b1, W2, b2
```

Yapay sinir ağının sonucunda tahmin işleminin yapılacağı fonksiyonun tanımlanması gerekmektedir. Tahmin işlemi için gerekli fonksiyon tanımlandıktan sonra doğru tahmin oranını hesaplamak için accuracy fonksiyonunun tanımlanması gerekmektedir.

```python
def get_predictions(A2):
    return np.argmax(A2, 0)

def get_accuracy(predictions, Y):
    print(predictions, Y)
    return np.sum(predictions == Y) / Y.size
```

Çalışmada gerekli olan fonksiyonların hepsi tanımlandıktan sonra tanımlanan tüm fonksiyonları birleştirmek ve yapay sinir ağına ait asıl fonksiyonu tanımlama işleminin gerçekleşitirilmesi gerekmektedir.
```python
def ANN(X, Y, alpha, iterations):
    W1, b1, W2, b2 = init_params()
    for i in range(iterations):
        Z1, A1, Z2, A2 = forward_prop(W1, b1, W2, b2, X)
        dW1, db1, dW2, db2 = backward_prop(Z1, A1, Z2, A2, W1, W2, X, Y)
        W1, b1, W2, b2 = update_params(W1, b1, W2, b2, dW1, db1, dW2, db2, alpha)
        if i % 10 == 0:
            print("Iteration: ", i)
            predictions = get_predictions(A2)
            print(get_accuracy(predictions, Y))
    return W1, b1, W2, b2
```

Yapay sinir ağına ait fonksiyonu tanımladıktan sonra eğitim verisetine ait girdi ve çıktılar ile birlikte öğrenme katsayısı ve iterasyon miktarını fonksiyona girerek öğrenme işleminin gerçekleştirilir.
```python
W1, b1, W2, b2 = ANN(X_train, Y_train, 0.1, 1000)
```

![](https://i.imgur.com/2F1m5QV.png)

Eğitim işlemi gerçekleştirildikten sonra hesaplanan çıktı ile beklenen çıktının incelenmesi için make_predictions fonksiyonunun tanımlanması gerekmektedir. Ayrıca çıktıların test edilmesi için de test_prediction fonksiyonlarının tanımlanması gerekmektedir.
```python
def make_predictions(X, W1, b1, W2, b2):
    _, _, _, A2 = forward_prop(W1, b1, W2, b2, X)
    predictions = get_predictions(A2)
    return predictions

def test_prediction(index, W1, b1, W2, b2):
    current_image = X_train[:, index, None]
    prediction = make_predictions(X_train[:, index, None], W1, b1, W2, b2)
    label = Y_train[index]
    print("Prediction: ", prediction)
    print("Label: ", label)
    
    current_image = current_image.reshape((28, 28)) * 255
    plt.gray()
    plt.imshow(current_image, interpolation='nearest')
    plt.show()
```

Çıktıların karşılaştırılması için gerekli tanımların yapılmasından sonra aşağıdaki istenilen bir değer analize girilerek sonucu incelenebilir.

```python 
test_prediction(0, W1, b1, W2, b2)
test_prediction(22, W1, b1, W2, b2)
test_prediction(50, W1, b1, W2, b2)
```

![](https://i.imgur.com/S4ILQ7A.png)


Son olarak da oluşturulan yapay sinir ağı modelinin test veri seti üzerindeki performansına bakılarak ağın başarısı incelenir.

```python
test_predictions = make_predictions(X_test, W1, b1, W2, b2)
get_accuracy(test_predictions, Y_test)
```

![](https://i.imgur.com/XO4NCgg.png)

Test Veri Seti Üzerinde 300 iterasyon sonucunda yaklaşık  %77 doğru tahmin oranı bulunmaktadır.